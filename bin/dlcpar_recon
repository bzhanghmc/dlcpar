#!/usr/bin/env python

VERSION = "1.0.0"

# python libraries
import os, sys, optparse
import StringIO

# dlcpar libraries
import dlcpar
from dlcpar import common

# rasmus and compbio libraries
from rasmus import treelib, util, timer
from compbio import phylo, alignlib

#==========================================================
# parser

def move_option(parser, opt_str, opt_grp):
    """Move option 'opt_str' from 'parser' to 'opt_grp'"""
    if parser.has_option(opt_str):
        opt = parser.get_option(opt_str)
        parser.remove_option(opt_str)
        opt_grp.add_option(opt)

def parse_args():
    """parse input arguments"""
    
    parser = optparse.OptionParser(
        usage = "usage: %prog [options] <gene tree> ...",
        
        version = "%prog " + VERSION,

        description =
             "dlcpar_recon is a phylogenetic program for finding the most parsimonious gene tree-species tree reconciliation " +
	     "by inferring speciation, duplication, loss, and deep coalescence events. " +
	     "See http://compbio.mit.edu/dlcpar for details.",
             
        epilog =
             "Written by Yi-Chieh Wu (yjw@mit.edu), Massachusetts Institute of Technology. " +
             "(c) 2012. Released under the terms of the GNU General Public License.")

    grp_io = optparse.OptionGroup(parser, "Input/Output")
    grp_io.add_option("-s", "--stree", dest="stree",
	              metavar="<species tree>",
		      help="species tree file in newick format")
    grp_io.add_option("-S", "--smap", dest="smap",
	              metavar="<species map>",
	              help="gene to species map")
    grp_io.add_option("-d", "--dcs", dest="dcs",
                      metavar="<DCS threshold>",
		      default=0.25, type="float",
		      help="duplication consistency score threshold: " +
		           "DCS >/<= thr resolves to DUP/COAL (default: 0.25)")
    grp_io.add_option("--eq", dest="eq",
                      default=False, action="store_true",
                      help="switches equality assignment for DCS threshold, " +
                      "i.e. DCS >=/< thr resolves to DUP/COAL")
    parser.add_option_group(grp_io)

    grp_ext = optparse.OptionGroup(parser, "File Extensions")
    grp_ext.add_option("-I","--inputext", dest="inputext",
	               metavar="<input file extension>",
	               default="",
	               help="input file extension (default: \"\")")
    grp_ext.add_option("-O", "--outputext", dest="outputext",
                       metavar="<output file extension>",
                       default=".dlcpar",
                       help="output file extension (default: \".dlcpar\")")
    parser.add_option_group(grp_ext)

    grp_info = optparse.OptionGroup(parser, "Information")
    move_option(parser, "--version", grp_info)
    move_option(parser, "--help", grp_info)
    grp_info.add_option("-V", "--verbose", dest="verbose",
                        metavar="<verbosity level>",
                        default="0", choices=["0","1","2","3"],
                        help="verbosity level (0=quiet, 1=low, 2=medium, 3=high)")
    grp_info.add_option("-l", "--log", dest="log",
                        metavar="<log file>",
                        default="-",
                        help="log filename.  Use '-' to display on stdout.")
    parser.add_option_group(grp_info)

    options, args = parser.parse_args()
    if not options.input and len(args) == 0:
        parser.print_help()
	sys.exit(1)

    #=============================
    # check arguments

    # required options
    if (not options.stree) or (not options.smap):
        parser.error("-s/--stree and -S/--smap required")
    options.verbose = int(options.verbose)

    # other options
    if options.dcs < 0 or options.dcs > 1:
        parser.error("--alpha/-p/--pval must be in [0,1]: %.5g" % options.alpha)

    # input gene tree files
    treefiles = get_input_files(parser, options, args)
    if len(treefiles) == 0:
        parser.error("must specify input file(s)")

    return options, treefiles

#==========================================================
# utilities

def get_input_files(parser, options, args):
    """Determine input files from options"""
    infiles = []
    if options.input:
        for arg in options.input:
            if arg == "-":
	        infiles.append(sys.stdin)
	    else:
	        infiles.append(open(arg))

    # determine all input lines
    files = args
    for infile in infiles:
        files.extend(map(lambda fn:fn.rstrip("\n"),infile.readlines()))
    if len(files) == 0:
        parser.error("must specify input file(s)")
					            
    return files

#==========================================================
# main

def main():
    """main"""
    
    # parse arguments
    options, treefiles = parse_args()
    if options.verbose >= 1:
        global log

    # read species tree and species map
    stree = treelib.read_tree(options.stree)
    gene2species = phylo.read_gene2species(options.smap)

    # process genes trees
    for treefile in treefiles:
        # seed random generator
        if options.seed:
            seed = options.seed
        else:
            seed = int(timer.time.time())
        random.seed(seed)
        if NUMPY:
            nprnd.seed(seed)

        # start log
        if options.verbose >= 1:
            log.start("Working on file '%s'" % treefile)
            log.log("random seed: %s\n" % seed)

        # setup files
        alnfile = util.replace_ext(treefile, options.oldext, options.alignext)
        outfile = util.replace_ext(treefile, options.oldext, options.newext)

        # read input tree
        gtrees = treelib.read_trees(treefile)
        if len(gtrees) != 1:
            print >>sys.stderr, "ERROR: treefile contains multiple trees: %s" % treefile
            return 1
        gtree = gtrees[0]

        # runtime statistics
        runtime_prop = 0
        runtime_reconroot = 0
        runtime_cost = 0
        runtime_stat = 0

        # special cases -- no need to search
        #   small gene tree
        #   input gene tree achieved minimum cost
        if check_small_tree(gtree, rooted=rooted) or \
           check_input_tree(gtree, stree, gene2species, smodule):
            # output tree
            gtree.write(outfile, oneline=False)

            # add bootstraps
            if options.nboot > 1:
                phylo.add_bootstraps(gtree, [gtree], rooted=True)

            # log
            if options.verbose >= 1:
                log.stop(); log.log("")

            # skip rest of algorithm
            continue

        # remove bootstraps and dists if present
        for node in gtree:
            node.dist = 0
            if "boot" in node.data:
                del node.data["boot"]
        if "boot" in gtree.default_data:
            del gtree.default_data["boot"]

        # read alignment
        aln = alignlib.fasta.read_fasta(alnfile)
        alnlen = len(aln.values()[0])

        # read user tree
        if options.usertreeext:
            usertreefile = util.replace_ext(treefile, options.oldext, options.usertreeext)
            usertree = treelib.read_tree(usertreefile)
            if options.verbose >= 1:
                log.log("user: tree")
                log_tree(usertree, log, writeDists=True)
                log_tree(usertree, log, oneline=False, writeDists=True)
            usertreehash_rooted = phylo.hash_tree(usertree)
            usertreehash_unrooted = phylo.hash_tree(unroot(usertree, newCopy=True))
            usertreehash = usertreehash_rooted if rooted else usertreehash_unrooted
        else:
            usertree = None
        
        # store input tree and whether input tree matches user tree
        treehash0_rooted = phylo.hash_tree(gtree)
        treehash0_unrooted = phylo.hash_tree(unroot(gtree, newCopy=True))
        treehash0 = treehash0_rooted if rooted else treehash0_unrooted
        if usertree:
            if set(usertree.leaf_names()) != set(gtree.leaf_names()):
                print >>sys.stderr, "ERROR: gene tree and user tree contain different genes"
                return 1
            searched_user_rooted0 = treehash0_rooted == usertreehash_rooted
            searched_user_unrooted0 = treehash0_unrooted == usertreehash_unrooted

        # setup output
        if options.nboot == 1:
            boot = False
        else:
            boot = True
            boottreefile = util.replace_ext(treefile, options.oldext, options.boottreeext)
            out = util.open_stream(boottreefile, "w")

        # main algorithm
        for bootnum in xrange(options.nboot):       # bootstrap search           
            # get bootstrapped alignment (equal number of columns, sample with replacement)
            if boot:
                if options.verbose >= 1:
                    log.start("boot: %d" % bootnum); log.log("")

                random.seed(seed + bootnum*4096)
                if NUMPY:
                    nprnd.seed(seed + bootnum*4096)
                    cols = nprnd.randint(alnlen, size=alnlen)
                else:
                    cols = [random.randint(0, alnlen-1) for _ in xrange(alnlen)]
                baln = alignlib.subalign(aln, cols)
            else:
                baln = aln
                    
            # search
            mintree = search_landscape(gtree, stree, gene2species, baln,
                                       module, smodule, rooted,
                                       seednum=bootnum+boot+1)

            # output bootstrap tree
            if boot:
                mintree.write(out, oneline=True)
                out.write('\n')
                if options.verbose >= 1:
                    log.stop(); log.log("")

        # write optimal tree or get optimal tree with bootstrap support
        if not boot:
            mintree.write(outfile)
        else:
            out.close()
            if options.verbose >= 1:
                log.start("boot: final"); log.log("")
            
            # search
            mintree = search_landscape(gtree, stree, gene2species, aln,
                                       module, smodule, rooted)

            # add bootstraps
            phylo.add_bootstraps(mintree, treelib.iter_trees(boottreefile), rooted=True)

            # log final tree with bootstraps
            log_tree(mintree, log)
            log_tree(mintree, log, oneline=False)
            
            # output tree
            mintree.write(outfile)
            if options.verbose >= 1:
                log.stop(); log.log("")

        # output runtime statistics
        if options.verbose >= 1:
            log.log("proposal runtime:\t%f" % runtime_prop)
            log.log("reconroot runtime:\t%f" % runtime_reconroot)
            log.log("cost runtime:\t%f" % runtime_cost)
            log.log("statistic runtime:\t%f" % runtime_stat)

        # stop log
        if options.verbose >= 1: log.stop(); log.log("\n\n")

    # close log
    if options.verbose >= 1 and options.log != "-":
        outlog.close()

# main function
if __name__ == "__main__":
    main()
